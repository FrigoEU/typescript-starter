{
  "version": 3,
  "sources": ["../../node_modules/browser-split/index.js", "../../node_modules/indexof/index.js", "../../node_modules/class-list/index.js", "empty:/home/simon/projects/typescript-starter/node_modules/html-element/index.js", "../../node_modules/hyperscript/index.js", "../../src/client/mycomponent.tsx", "../../src/lib/reactive.ts"],
  "sourcesContent": ["/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n", "\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};", "// contains, add, remove, toggle\nvar indexof = require('indexof')\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (indexof(list, token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = indexof(list, token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return indexof(getTokens(), token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return filter(className.split(\" \"), isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction filter (arr, fn) {\n    var ret = []\n    for (var i = 0; i < arr.length; i++) {\n        if (fn(arr[i])) ret.push(arr[i])\n    }\n    return ret\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n", "", "var split = require('browser-split')\nvar ClassList = require('class-list')\n\nvar w = typeof window === 'undefined' ? require('html-element') : window\nvar document = w.document\nvar Text = w.Text\n\nfunction context () {\n\n  var cleanupFuncs = []\n\n  function h() {\n    var args = [].slice.call(arguments), e = null\n    function item (l) {\n      var r\n      function parseClass (string) {\n        // Our minimal parser doesn\u2019t understand escaping CSS special\n        // characters like `#`. Don\u2019t use them. More reading:\n        // https://mathiasbynens.be/notes/css-escapes .\n\n        var m = split(string, /([\\.#]?[^\\s#.]+)/)\n        if(/^\\.|#/.test(m[1]))\n          e = document.createElement('div')\n        forEach(m, function (v) {\n          var s = v.substring(1,v.length)\n          if(!v) return\n          if(!e)\n            e = document.createElement(v)\n          else if (v[0] === '.')\n            ClassList(e).add(s)\n          else if (v[0] === '#')\n            e.setAttribute('id', s)\n        })\n      }\n\n      if(l == null)\n        ;\n      else if('string' === typeof l) {\n        if(!e)\n          parseClass(l)\n        else\n          e.appendChild(r = document.createTextNode(l))\n      }\n      else if('number' === typeof l\n        || 'boolean' === typeof l\n        || l instanceof Date\n        || l instanceof RegExp ) {\n          e.appendChild(r = document.createTextNode(l.toString()))\n      }\n      //there might be a better way to handle this...\n      else if (isArray(l))\n        forEach(l, item)\n      else if(isNode(l))\n        e.appendChild(r = l)\n      else if(l instanceof Text)\n        e.appendChild(r = l)\n      else if ('object' === typeof l) {\n        for (var k in l) {\n          if('function' === typeof l[k]) {\n            if(/^on\\w+/.test(k)) {\n              (function (k, l) { // capture k, l in the closure\n                if (e.addEventListener){\n                  e.addEventListener(k.substring(2), l[k], false)\n                  cleanupFuncs.push(function(){\n                    e.removeEventListener(k.substring(2), l[k], false)\n                  })\n                }else{\n                  e.attachEvent(k, l[k])\n                  cleanupFuncs.push(function(){\n                    e.detachEvent(k, l[k])\n                  })\n                }\n              })(k, l)\n            } else {\n              // observable\n              e[k] = l[k]()\n              cleanupFuncs.push(l[k](function (v) {\n                e[k] = v\n              }))\n            }\n          }\n          else if(k === 'style') {\n            if('string' === typeof l[k]) {\n              e.style.cssText = l[k]\n            }else{\n              for (var s in l[k]) (function(s, v) {\n                if('function' === typeof v) {\n                  // observable\n                  e.style.setProperty(s, v())\n                  cleanupFuncs.push(v(function (val) {\n                    e.style.setProperty(s, val)\n                  }))\n                } else\n                  var match = l[k][s].match(/(.*)\\W+!important\\W*$/);\n                  if (match) {\n                    e.style.setProperty(s, match[1], 'important')\n                  } else {\n                    e.style.setProperty(s, l[k][s])\n                  }\n              })(s, l[k][s])\n            }\n          } else if(k === 'attrs') {\n            for (var v in l[k]) {\n              e.setAttribute(v, l[k][v])\n            }\n          }\n          else if (k.substr(0, 5) === \"data-\") {\n            e.setAttribute(k, l[k])\n          } else {\n            e[k] = l[k]\n          }\n        }\n      } else if ('function' === typeof l) {\n        //assume it's an observable!\n        var v = l()\n        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))\n\n        cleanupFuncs.push(l(function (v) {\n          if(isNode(v) && r.parentElement)\n            r.parentElement.replaceChild(v, r), r = v\n          else\n            r.textContent = v\n        }))\n      }\n\n      return r\n    }\n    while(args.length)\n      item(args.shift())\n\n    return e\n  }\n\n  h.cleanup = function () {\n    for (var i = 0; i < cleanupFuncs.length; i++){\n      cleanupFuncs[i]()\n    }\n    cleanupFuncs.length = 0\n  }\n\n  return h\n}\n\nvar h = module.exports = context()\nh.context = context\n\nfunction isNode (el) {\n  return el && el.nodeName && el.nodeType\n}\n\nfunction forEach (arr, fn) {\n  if (arr.forEach) return arr.forEach(fn)\n  for (var i = 0; i < arr.length; i++) fn(arr[i], i)\n}\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\n\n", "import h from \"hyperscript\";\nimport { Source, dyn, active, component, Component } from \"../lib/reactive\";\n\n// still TODO:\n// * dyn on server: Gaat niet. Clientside code moet apart gecompileerd worden. Het enige wat soms zou lukken is de code van de dyn zelf serializen, maar je krijgt de closure niet mee dus je hebt heel rare semantics\n\n// (* firefox heeft coole tooling om je naar definitie van custom element te brengen -> kunnen we dat gebruiken?)\n\n/*\n * Je moet zeker zijn dat alle clientside componenten die je op server gebruikt in clientside bundle zitten.\n   Het makkelijkste is 1 grote js file maken met alle componenten in. Maar je moet ze wel in 1 file krijgen, dus dan heb je ergens een centrale clientside file waar alles instaat dat naar de clientside moet? Misschien wat ambetant om te updaten en makkelijk te vergeten?\n   Een andere (ingewikkeldere?) mogelijkheid is om de typescript compiler API los te laten op de serverside code en alle files in bepaalde folders zoals /client te zoeken die geimport werden\n   -> Maar da's eigenlijk het werk van een bundler... Misschien kan esbuild zoiets voor ons doen?\n */\n\nexport const countershower: Component<{ counter: Source<number> }> = component(\n  \"my-countershower\",\n  function (c) {\n    return dyn(c.counter, (count) => <span>{count}</span>);\n  }\n);\n\nexport const countershower2: Component<{ counter: Source<number> }> = component(\n  \"my-countershower2\",\n  function (c) {\n    return (\n      <div>\n        {dyn(c.counter, (count) => (\n          <span>{count}</span>\n        ))}\n      </div>\n    );\n  }\n);\n\nexport const counterbutton: Component<{\n  counter: Source<number>;\n}> = component(\"my-counterbutton\", (c) => (\n  <button onclick={() => c.counter.set(c.counter.get() + 1)}>one up</button>\n));\n\nexport const myfleeflers: Component<{ something: string }> = component(\n  \"my-fleeflers\",\n  function (c) {\n    const mysource = new Source(0);\n    setInterval(function () {\n      mysource.set(mysource.get() + 1);\n    }, 1000);\n    return (\n      <div>\n        fleeflers: {c.something}\n        {dyn(mysource, function (val: number): HTMLElement {\n          return h(\"span\", {}, val.toString());\n        })}\n      </div>\n    );\n  }\n);\n\nexport const mybleebers: Component<{ content: string }> = component(\n  \"my-bleebers\",\n  function (c) {\n    return (\n      <div>\n        bleebers: {c.content}\n        {active(myfleeflers, { something: \"wack\" })}\n      </div>\n    );\n  }\n);\n", "import h from \"hyperscript\";\n\nfunction findNonSerializable(obj: any): any | null {\n  function isPlain(val: any) {\n    return (\n      typeof val === \"undefined\" ||\n      typeof val === \"string\" ||\n      typeof val === \"boolean\" ||\n      typeof val === \"number\" ||\n      Array.isArray(val) ||\n      (val.constructor === Object && // don't allow classes or functions\n        val.toString() === \"[object Object]\")\n    );\n  }\n  // Special casing ServersideSource: We CAN serialize this from server to client,\n  //   as long as the value itself is serializable (ie. not a function or class)\n  if (obj.tag === \"ServersideSource\") {\n    const nonSerializableVal = findNonSerializable(obj.value);\n    if (nonSerializableVal) {\n      return nonSerializableVal;\n    } else {\n      return null;\n    }\n  }\n  if (!isPlain(obj)) {\n    return obj;\n  }\n  if (Array.isArray(obj) || typeof obj === \"object\") {\n    for (var property in obj) {\n      if (obj.hasOwnProperty(property)) {\n        const nonSerializableNested = findNonSerializable(obj[property]);\n        if (nonSerializableNested) {\n          return nonSerializableNested;\n        }\n      }\n    }\n  }\n}\n\nfunction errPrintFunction(f: Function): string {\n  return `\nFunction name: ${f.name}\nFunction body: ${f.toString()}.\n\nWrap this in another component so function definition happens on client side.\n`;\n}\n\n// function to initialize an instance of a component that needs to be rendered clientside\n// when called serverside:\n//   render into a custom element + a template inside.\n//   clientside initialization (registerOnClient) knows to look for these template elements\n// when called clientside:\n//   render as custom element and set props on custom element\n//   registerOnClient knows to look on .props attribute\nexport function active<Props>(c: Component<Props>, p: Props): HTMLElement {\n  if (typeof window === \"undefined\") {\n    // serverside: stringify into template\n    if (process.env.NODE_ENV === \"production\") {\n      // in production: don't check anything, following check is rather expensive\n    } else {\n      debugger;\n      // in development: make sure everything is serializable\n      const nonSerializable: any = findNonSerializable(p);\n      if (nonSerializable) {\n        throw new Error(\n          `During serialization of properties for component ${c.name}.\nCan't serialize on serverside:\n${\n  typeof nonSerializable === \"function\"\n    ? errPrintFunction(nonSerializable)\n    : JSON.stringify(nonSerializable)\n}`\n        );\n      }\n    }\n    return h(c.name, {}, h(\"template\", {}, JSON.stringify(p)));\n  } else {\n    // clientside: pass as prop on custom element\n    const a: HTMLElement = h(c.name, {}, null);\n    (a as any).props = p;\n    return a;\n  }\n}\n\n// Basic type of (clientside) dynamic values = values that can change over time\nexport interface Source<T> {\n  get(): T;\n  set(newval: T): void;\n  observe(f: (currentVal: T, unsub: () => void) => void): void;\n}\n\n// Only clientside! Serverside: use initServersideSources\nexport const Source = class ClientSource<T> implements Source<T> {\n  private value: T;\n  private observers: ((currentVal: T, unsub: () => void) => void)[];\n\n  constructor(value: T) {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"Don't use this serverside, use initServersideSources.\");\n    }\n    this.value = value;\n    this.observers = [];\n  }\n  get(): T {\n    return this.value;\n  }\n  set(newval: T): void {\n    this.value = newval;\n    const observersToRemove: number[] = [];\n    this.observers.forEach(function (obs, i) {\n      obs(newval, () => observersToRemove.push(i));\n    }, null);\n    observersToRemove.reverse().forEach((i) => {\n      this.observers.splice(i, 1);\n    });\n  }\n  observe(f: (currentVal: T, unsub: () => void) => void): void {\n    this.observers.push(f);\n  }\n};\n\n// We dynamically make a new class in this function, so we can keep\n// track of every source that was made during serverside render\n// and we can serialize them into the page with a single function = genServersideHeader\nexport function initServersideSources() {\n  if (typeof window !== \"undefined\") {\n    throw new Error(\"Only usable on server side!\");\n  }\n\n  class ServersideSource<T> implements Source<T> {\n    private i: number;\n    private static genned: boolean = false;\n    private static sourceI = 0;\n    // Used to serialize all made sources into window.sources\n    private static sources: { [key: string]: ServersideSource<any> } = {};\n\n    private value: T;\n    tag: string = \"ServersideSource\";\n    static genServersideHeader() {\n      ServersideSource.genned = true;\n      const sourceAssignments = Object.keys(ServersideSource.sources)\n        .map(function (key) {\n          return `\\\"${key}\\\": ${JSON.stringify(ServersideSource.sources[key].get())}`;\n        })\n        .join(\",\");\n      return h(\n        \"script\",\n        {},\n        `window.sources = JSON.parse('{${sourceAssignments}}');`\n      );\n    }\n    constructor(value: T) {\n      if (ServersideSource.genned) {\n        throw new Error(\n          \"Serverside header already generated, can't make new sources anymore!\"\n        );\n      }\n      this.value = value;\n      this.i = ServersideSource.sourceI;\n      ServersideSource.sourceI = ServersideSource.sourceI + 1;\n\n      ServersideSource.sources[this.i] = this;\n    }\n    get(): T {\n      return this.value;\n    }\n    set(v: T): void {\n      if (ServersideSource.genned) {\n        throw new Error(\n          \"Serverside header already generated, can't set source anymore!\"\n        );\n      }\n      this.value = v;\n    }\n    observe(): void {}\n    toJSON(): Object {\n      return {\n        tag: \"source\",\n        i: this.i,\n      };\n    }\n  }\n\n  function mkSource<T>(a: T) {\n    return new ServersideSource(a);\n  }\n\n  return {\n    Source: ServersideSource,\n    mkSource: mkSource,\n  };\n}\n\n// Used clientside to lookup sources from server\nconst sourcesFromServer: { [key: string]: Source<any> } = (function () {\n  const w =\n    typeof window === \"undefined\" ? (undefined as any) : (window as any);\n  if (typeof w === \"undefined\") {\n    return {};\n  } else {\n    Object.keys(w.sources).forEach(function (key) {\n      w.sources[key] = new Source(w.sources[key]);\n    });\n    return w.sources;\n  }\n})();\n\nfunction findSourcesFromServer(_: any, x: any) {\n  if (\n    typeof x === \"object\" &&\n    typeof x.tag !== \"undefined\" &&\n    x.tag === \"source\" &&\n    typeof x.i !== \"undefined\"\n  ) {\n    const found = sourcesFromServer[x.i];\n    if (!found) {\n      throw new Error(\n        \"Source from server not found for i: \" +\n          x.i +\n          \". Did you generate the header script with .genServersideHeader()?\"\n      );\n    } else {\n      return found;\n    }\n  }\n  return x;\n}\n\n// Main function to hook up input props to components\nfunction registerOnClient<ConstProps>(c: Component<ConstProps>): void {\n  customElements.define(\n    c.name,\n    class extends HTMLElement {\n      constructor() {\n        super();\n      }\n      connectedCallback() {\n        const root = this.attachShadow({ mode: \"open\" });\n        if (\n          this.children[0] &&\n          this.children[0].tagName.toUpperCase() === \"TEMPLATE\"\n        ) {\n          // Comes from serverside = everything is serialized into a <template>\n          const templ = this.children[0] as HTMLTemplateElement;\n          const data: ConstProps = JSON.parse(\n            templ.content.textContent || \"\",\n            findSourcesFromServer\n          );\n\n          root.append(c.run(data as Immutable<ConstProps>));\n        } else {\n          // Comes from clientside = everything is added to a \"props\" property\n          root.append(c.run((this as any).props as Immutable<ConstProps>));\n        }\n      }\n    }\n  );\n}\n\nexport type Immutable<T> = T extends\n  | Function\n  | boolean\n  | number\n  | string\n  | null\n  | undefined\n  ? T\n  : T extends Array<infer U>\n  ? ReadonlyArray<Immutable<U>>\n  : T extends Map<infer K, infer V>\n  ? ReadonlyMap<Immutable<K>, Immutable<V>>\n  : T extends Set<infer S>\n  ? ReadonlySet<Immutable<S>>\n  : { readonly [P in keyof T]: Immutable<T[P]> };\n\n// Function to define a new component\n// Takes care of registering custom element with browser if on client side\n// Asks for immutable properties, so it's clear that changing them will not\n// update the view\nexport type Component<Props> = {\n  name: string;\n  run: (p: Immutable<Props>) => HTMLElement;\n};\nexport function component<Props>(\n  name: string,\n  run: (p: Immutable<Props>) => HTMLElement\n): Component<Props> {\n  const comp = { name, run };\n  if (typeof window !== \"undefined\") {\n    registerOnClient(comp);\n  }\n  return comp;\n}\n\n// Client side only function of making an HTML fragment that can change\n// based on the value of a source\n//\n// TODO memory leaks?\nexport function dyn<T>(\n  s: Source<T>,\n  render: (v: T) => HTMLElement\n): HTMLElement {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"Can't use dyn on clientside. Wrap code in a component and use active instead.\"\n    );\n  }\n  const currv = s.get();\n  let el = render(currv);\n  s.observe(function (newv, unsubscribe) {\n    let newel = render(newv);\n    const p = el.parentNode;\n    if (p && p.isConnected) {\n      p.replaceChild(newel, el);\n      el = newel;\n    } else {\n      console.log(\"Unsubscribing\");\n      unsubscribe();\n    }\n  });\n  return el;\n}\n"],
  "mappings": "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",
  "names": []
}
